"""Basic vulnerability scanner (fallback when Trivy unavailable)"""

import asyncio
import logging
import json
import subprocess
from pathlib import Path
from typing import List, Optional, Union, Dict
import re

from netsec_container.core.results import Vulnerability
from netsec_container.core.image_extractor import ImageExtractor

logger = logging.getLogger(__name__)


class BasicVulnerabilityScanner:
    """Basic vulnerability scanner without Trivy"""
    
    def __init__(self):
        self.name = "Basic Vulnerability Scanner"
        self.image_extractor = ImageExtractor()
        self.package_managers = {
            "dpkg": self._parse_dpkg,
            "rpm": self._parse_rpm,
            "apk": self._parse_apk,
            "pip": self._parse_pip,
            "npm": self._parse_npm,
        }
    
    async def scan(
        self,
        image: str,
        image_path: Optional[Union[str, Path]] = None,
    ) -> List[Vulnerability]:
        """
        Basic vulnerability scan
        
        Args:
            image: Container image name/tag
            image_path: Path to saved image tar file
            
        Returns:
            List of Vulnerability objects
        """
        vulnerabilities = []
        
        try:
            # Extract image if needed
            extracted_path = None
            if image_path:
                extracted_path = self.image_extractor.extract_tar_file(image_path)
            else:
                extracted_path = await self.image_extractor.extract_image(image)
            
            if not extracted_path:
                logger.warning("Could not extract image for basic vulnerability scanning")
                return vulnerabilities
            
            # Find package manager files
            packages = await self._discover_packages(extracted_path)
            
            # For now, return packages as info-level findings
            # In a full implementation, we'd query CVE databases
            for pkg_info in packages:
                vuln = Vulnerability(
                    cve_id=f"PKG-{pkg_info['name']}-{pkg_info['version']}",
                    package=pkg_info['name'],
                    version=pkg_info['version'],
                    severity="info",
                    score=0.0,
                    description=f"Package {pkg_info['name']} {pkg_info['version']} found (CVE check requires database)",
                    fixed_version=None,
                    exploit_available=False,
                )
                vulnerabilities.append(vuln)
            
            # Cleanup
            if extracted_path and extracted_path.exists():
                import shutil
                parent = extracted_path.parent
                if parent.name.startswith("netsec_container_"):
                    shutil.rmtree(parent, ignore_errors=True)
        
        except Exception as e:
            logger.error(f"Basic vulnerability scan error: {e}", exc_info=True)
        
        return vulnerabilities
    
    async def _discover_packages(self, extracted_path: Path) -> List[Dict]:
        """Discover installed packages"""
        packages = []
        
        # Check for package manager files
        package_files = {
            "dpkg": ["var/lib/dpkg/status"],
            "rpm": ["var/lib/rpm/Packages"],
            "apk": ["lib/apk/db/installed"],
            "pip": ["usr/local/lib/python*/site-packages"],
            "npm": ["usr/local/lib/node_modules"],
        }
        
        for pkg_mgr, paths in package_files.items():
            for rel_path in paths:
                full_path = extracted_path / rel_path
                
                # Handle glob patterns
                if "*" in rel_path:
                    matches = list(extracted_path.glob(rel_path))
                    for match in matches:
                        if match.is_dir():
                            packages.extend(await self._scan_package_dir(match, pkg_mgr))
                elif full_path.exists():
                    parser = self.package_managers.get(pkg_mgr)
                    if parser:
                        packages.extend(await parser(full_path))
        
        return packages
    
    async def _scan_package_dir(self, directory: Path, pkg_mgr: str) -> List[Dict]:
        """Scan package directory for packages"""
        packages = []
        
        try:
            if pkg_mgr == "pip":
                # Look for .dist-info directories
                for dist_info in directory.glob("*.dist-info"):
                    metadata_file = dist_info / "METADATA"
                    if metadata_file.exists():
                        pkg_info = await self._parse_pip_metadata(metadata_file)
                        if pkg_info:
                            packages.append(pkg_info)
            
            elif pkg_mgr == "npm":
                # Look for package.json files
                for pkg_json in directory.rglob("package.json"):
                    pkg_info = await self._parse_npm_package(pkg_json)
                    if pkg_info:
                        packages.append(pkg_info)
        
        except Exception as e:
            logger.debug(f"Error scanning {pkg_mgr} directory: {e}")
        
        return packages
    
    async def _parse_dpkg(self, status_file: Path) -> List[Dict]:
        """Parse dpkg status file"""
        packages = []
        
        try:
            with open(status_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
                
                # Parse dpkg status format
                for block in content.split("\n\n"):
                    if not block.strip():
                        continue
                    
                    name = None
                    version = None
                    
                    for line in block.split("\n"):
                        if line.startswith("Package: "):
                            name = line.split(": ", 1)[1].strip()
                        elif line.startswith("Version: "):
                            version = line.split(": ", 1)[1].strip()
                    
                    if name and version:
                        packages.append({"name": name, "version": version, "manager": "dpkg"})
        
        except Exception as e:
            logger.debug(f"Error parsing dpkg status: {e}")
        
        return packages
    
    async def _parse_rpm(self, packages_file: Path) -> List[Dict]:
        """Parse RPM packages file"""
        # RPM database is binary, would need rpm library
        # For now, return empty
        logger.debug("RPM parsing not fully implemented (requires rpm library)")
        return []
    
    async def _parse_apk(self, installed_file: Path) -> List[Dict]:
        """Parse Alpine apk installed file"""
        packages = []
        
        try:
            with open(installed_file, "r", encoding="utf-8", errors="ignore") as f:
                for line in f:
                    # Format: P:package-name:version:...
                    if line.startswith("P:"):
                        parts = line.split(":")
                        if len(parts) >= 3:
                            packages.append({
                                "name": parts[1],
                                "version": parts[2],
                                "manager": "apk"
                            })
        
        except Exception as e:
            logger.debug(f"Error parsing apk installed: {e}")
        
        return packages
    
    async def _parse_pip(self, site_packages: Path) -> List[Dict]:
        """Parse pip packages from site-packages"""
        packages = []
        
        # This is called for directory, use _scan_package_dir instead
        return packages
    
    async def _parse_pip_metadata(self, metadata_file: Path) -> Optional[Dict]:
        """Parse pip METADATA file"""
        try:
            with open(metadata_file, "r", encoding="utf-8", errors="ignore") as f:
                name = None
                version = None
                
                for line in f:
                    if line.startswith("Name: "):
                        name = line.split(": ", 1)[1].strip()
                    elif line.startswith("Version: "):
                        version = line.split(": ", 1)[1].strip()
                
                if name and version:
                    return {"name": name, "version": version, "manager": "pip"}
        
        except Exception as e:
            logger.debug(f"Error parsing pip metadata: {e}")
        
        return None
    
    async def _parse_npm(self, node_modules: Path) -> List[Dict]:
        """Parse npm packages from node_modules"""
        packages = []
        
        # This is called for directory, use _scan_package_dir instead
        return packages
    
    async def _parse_npm_package(self, package_json: Path) -> Optional[Dict]:
        """Parse npm package.json file"""
        try:
            with open(package_json, "r", encoding="utf-8", errors="ignore") as f:
                data = json.load(f)
                name = data.get("name")
                version = data.get("version")
                
                if name and version:
                    return {"name": name, "version": version, "manager": "npm"}
        
        except Exception as e:
            logger.debug(f"Error parsing npm package.json: {e}")
        
        return None
